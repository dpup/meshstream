// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: meshstream/meshstream.proto

package meshtreampb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	meshtastic "meshstream/generated/meshtastic"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Packet represents a complete decoded MQTT message
type Packet struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Info          *TopicInfo             `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
	Data          *Data                  `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Packet) Reset() {
	*x = Packet{}
	mi := &file_meshstream_meshstream_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Packet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Packet) ProtoMessage() {}

func (x *Packet) ProtoReflect() protoreflect.Message {
	mi := &file_meshstream_meshstream_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Packet.ProtoReflect.Descriptor instead.
func (*Packet) Descriptor() ([]byte, []int) {
	return file_meshstream_meshstream_proto_rawDescGZIP(), []int{0}
}

func (x *Packet) GetInfo() *TopicInfo {
	if x != nil {
		return x.Info
	}
	return nil
}

func (x *Packet) GetData() *Data {
	if x != nil {
		return x.Data
	}
	return nil
}

// TopicInfo contains parsed information about a Meshtastic MQTT topic
type TopicInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FullTopic     string                 `protobuf:"bytes,1,opt,name=full_topic,json=fullTopic,proto3" json:"full_topic,omitempty"`
	RegionPath    string                 `protobuf:"bytes,2,opt,name=region_path,json=regionPath,proto3" json:"region_path,omitempty"`
	Version       string                 `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	Format        string                 `protobuf:"bytes,4,opt,name=format,proto3" json:"format,omitempty"`
	Channel       string                 `protobuf:"bytes,5,opt,name=channel,proto3" json:"channel,omitempty"`
	UserId        string                 `protobuf:"bytes,6,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopicInfo) Reset() {
	*x = TopicInfo{}
	mi := &file_meshstream_meshstream_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopicInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopicInfo) ProtoMessage() {}

func (x *TopicInfo) ProtoReflect() protoreflect.Message {
	mi := &file_meshstream_meshstream_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopicInfo.ProtoReflect.Descriptor instead.
func (*TopicInfo) Descriptor() ([]byte, []int) {
	return file_meshstream_meshstream_proto_rawDescGZIP(), []int{1}
}

func (x *TopicInfo) GetFullTopic() string {
	if x != nil {
		return x.FullTopic
	}
	return ""
}

func (x *TopicInfo) GetRegionPath() string {
	if x != nil {
		return x.RegionPath
	}
	return ""
}

func (x *TopicInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *TopicInfo) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *TopicInfo) GetChannel() string {
	if x != nil {
		return x.Channel
	}
	return ""
}

func (x *TopicInfo) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

// Data provides a flattened structure for decoded Meshtastic packets
type Data struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// From Service Envelope
	ChannelId string `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	GatewayId string `protobuf:"bytes,2,opt,name=gateway_id,json=gatewayId,proto3" json:"gateway_id,omitempty"`
	// From Mesh Packet
	Id        uint32 `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	From      uint32 `protobuf:"varint,4,opt,name=from,proto3" json:"from,omitempty"`
	To        uint32 `protobuf:"varint,5,opt,name=to,proto3" json:"to,omitempty"`
	HopLimit  uint32 `protobuf:"varint,6,opt,name=hop_limit,json=hopLimit,proto3" json:"hop_limit,omitempty"`
	HopStart  uint32 `protobuf:"varint,7,opt,name=hop_start,json=hopStart,proto3" json:"hop_start,omitempty"`
	WantAck   bool   `protobuf:"varint,8,opt,name=want_ack,json=wantAck,proto3" json:"want_ack,omitempty"`
	Priority  string `protobuf:"bytes,9,opt,name=priority,proto3" json:"priority,omitempty"`
	ViaMqtt   bool   `protobuf:"varint,10,opt,name=via_mqtt,json=viaMqtt,proto3" json:"via_mqtt,omitempty"`
	NextHop   uint32 `protobuf:"varint,11,opt,name=next_hop,json=nextHop,proto3" json:"next_hop,omitempty"`
	RelayNode uint32 `protobuf:"varint,12,opt,name=relay_node,json=relayNode,proto3" json:"relay_node,omitempty"`
	// From Data
	PortNum meshtastic.PortNum `protobuf:"varint,13,opt,name=port_num,json=portNum,proto3,enum=meshtastic.PortNum" json:"port_num,omitempty"`
	// Payload is one of these types, depending on port_num
	//
	// Types that are valid to be assigned to Payload:
	//
	//	*Data_TextMessage
	//	*Data_BinaryData
	//	*Data_Position
	//	*Data_NodeInfo
	//	*Data_Telemetry
	//	*Data_Waypoint
	//	*Data_RouteDiscovery
	//	*Data_NeighborInfo
	//	*Data_CompressedText
	//	*Data_MapReport
	//	*Data_RemoteHardware
	//	*Data_Routing
	//	*Data_Admin
	//	*Data_AudioData
	//	*Data_Alert
	//	*Data_Reply
	//	*Data_IpTunnel
	//	*Data_Paxcounter
	//	*Data_SerialApp
	//	*Data_StoreForward
	//	*Data_RangeTest
	//	*Data_ZpsApp
	//	*Data_Simulator
	//	*Data_AtakPlugin
	//	*Data_Powerstress
	//	*Data_ReticulumTunnel
	//	*Data_PrivateApp
	//	*Data_DetectionSensor
	Payload isData_Payload `protobuf_oneof:"payload"`
	// Additional Data fields
	RequestId    uint32 `protobuf:"varint,50,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	ReplyId      uint32 `protobuf:"varint,51,opt,name=reply_id,json=replyId,proto3" json:"reply_id,omitempty"`
	Emoji        uint32 `protobuf:"varint,52,opt,name=emoji,proto3" json:"emoji,omitempty"`
	Dest         uint32 `protobuf:"varint,53,opt,name=dest,proto3" json:"dest,omitempty"`
	Source       uint32 `protobuf:"varint,54,opt,name=source,proto3" json:"source,omitempty"`
	WantResponse bool   `protobuf:"varint,55,opt,name=want_response,json=wantResponse,proto3" json:"want_response,omitempty"`
	// Error tracking
	DecodeError string `protobuf:"bytes,60,opt,name=decode_error,json=decodeError,proto3" json:"decode_error,omitempty"`
	// Reception timestamp (added by decoder)
	RxTime        uint64 `protobuf:"varint,61,opt,name=rx_time,json=rxTime,proto3" json:"rx_time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Data) Reset() {
	*x = Data{}
	mi := &file_meshstream_meshstream_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Data) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Data) ProtoMessage() {}

func (x *Data) ProtoReflect() protoreflect.Message {
	mi := &file_meshstream_meshstream_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Data.ProtoReflect.Descriptor instead.
func (*Data) Descriptor() ([]byte, []int) {
	return file_meshstream_meshstream_proto_rawDescGZIP(), []int{2}
}

func (x *Data) GetChannelId() string {
	if x != nil {
		return x.ChannelId
	}
	return ""
}

func (x *Data) GetGatewayId() string {
	if x != nil {
		return x.GatewayId
	}
	return ""
}

func (x *Data) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Data) GetFrom() uint32 {
	if x != nil {
		return x.From
	}
	return 0
}

func (x *Data) GetTo() uint32 {
	if x != nil {
		return x.To
	}
	return 0
}

func (x *Data) GetHopLimit() uint32 {
	if x != nil {
		return x.HopLimit
	}
	return 0
}

func (x *Data) GetHopStart() uint32 {
	if x != nil {
		return x.HopStart
	}
	return 0
}

func (x *Data) GetWantAck() bool {
	if x != nil {
		return x.WantAck
	}
	return false
}

func (x *Data) GetPriority() string {
	if x != nil {
		return x.Priority
	}
	return ""
}

func (x *Data) GetViaMqtt() bool {
	if x != nil {
		return x.ViaMqtt
	}
	return false
}

func (x *Data) GetNextHop() uint32 {
	if x != nil {
		return x.NextHop
	}
	return 0
}

func (x *Data) GetRelayNode() uint32 {
	if x != nil {
		return x.RelayNode
	}
	return 0
}

func (x *Data) GetPortNum() meshtastic.PortNum {
	if x != nil {
		return x.PortNum
	}
	return meshtastic.PortNum(0)
}

func (x *Data) GetPayload() isData_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *Data) GetTextMessage() string {
	if x != nil {
		if x, ok := x.Payload.(*Data_TextMessage); ok {
			return x.TextMessage
		}
	}
	return ""
}

func (x *Data) GetBinaryData() []byte {
	if x != nil {
		if x, ok := x.Payload.(*Data_BinaryData); ok {
			return x.BinaryData
		}
	}
	return nil
}

func (x *Data) GetPosition() *meshtastic.Position {
	if x != nil {
		if x, ok := x.Payload.(*Data_Position); ok {
			return x.Position
		}
	}
	return nil
}

func (x *Data) GetNodeInfo() *meshtastic.User {
	if x != nil {
		if x, ok := x.Payload.(*Data_NodeInfo); ok {
			return x.NodeInfo
		}
	}
	return nil
}

func (x *Data) GetTelemetry() *meshtastic.Telemetry {
	if x != nil {
		if x, ok := x.Payload.(*Data_Telemetry); ok {
			return x.Telemetry
		}
	}
	return nil
}

func (x *Data) GetWaypoint() *meshtastic.Waypoint {
	if x != nil {
		if x, ok := x.Payload.(*Data_Waypoint); ok {
			return x.Waypoint
		}
	}
	return nil
}

func (x *Data) GetRouteDiscovery() *meshtastic.RouteDiscovery {
	if x != nil {
		if x, ok := x.Payload.(*Data_RouteDiscovery); ok {
			return x.RouteDiscovery
		}
	}
	return nil
}

func (x *Data) GetNeighborInfo() *meshtastic.NeighborInfo {
	if x != nil {
		if x, ok := x.Payload.(*Data_NeighborInfo); ok {
			return x.NeighborInfo
		}
	}
	return nil
}

func (x *Data) GetCompressedText() []byte {
	if x != nil {
		if x, ok := x.Payload.(*Data_CompressedText); ok {
			return x.CompressedText
		}
	}
	return nil
}

func (x *Data) GetMapReport() *meshtastic.MapReport {
	if x != nil {
		if x, ok := x.Payload.(*Data_MapReport); ok {
			return x.MapReport
		}
	}
	return nil
}

func (x *Data) GetRemoteHardware() *meshtastic.HardwareMessage {
	if x != nil {
		if x, ok := x.Payload.(*Data_RemoteHardware); ok {
			return x.RemoteHardware
		}
	}
	return nil
}

func (x *Data) GetRouting() *meshtastic.Routing {
	if x != nil {
		if x, ok := x.Payload.(*Data_Routing); ok {
			return x.Routing
		}
	}
	return nil
}

func (x *Data) GetAdmin() *meshtastic.AdminMessage {
	if x != nil {
		if x, ok := x.Payload.(*Data_Admin); ok {
			return x.Admin
		}
	}
	return nil
}

func (x *Data) GetAudioData() []byte {
	if x != nil {
		if x, ok := x.Payload.(*Data_AudioData); ok {
			return x.AudioData
		}
	}
	return nil
}

func (x *Data) GetAlert() string {
	if x != nil {
		if x, ok := x.Payload.(*Data_Alert); ok {
			return x.Alert
		}
	}
	return ""
}

func (x *Data) GetReply() string {
	if x != nil {
		if x, ok := x.Payload.(*Data_Reply); ok {
			return x.Reply
		}
	}
	return ""
}

func (x *Data) GetIpTunnel() []byte {
	if x != nil {
		if x, ok := x.Payload.(*Data_IpTunnel); ok {
			return x.IpTunnel
		}
	}
	return nil
}

func (x *Data) GetPaxcounter() *meshtastic.Paxcount {
	if x != nil {
		if x, ok := x.Payload.(*Data_Paxcounter); ok {
			return x.Paxcounter
		}
	}
	return nil
}

func (x *Data) GetSerialApp() []byte {
	if x != nil {
		if x, ok := x.Payload.(*Data_SerialApp); ok {
			return x.SerialApp
		}
	}
	return nil
}

func (x *Data) GetStoreForward() []byte {
	if x != nil {
		if x, ok := x.Payload.(*Data_StoreForward); ok {
			return x.StoreForward
		}
	}
	return nil
}

func (x *Data) GetRangeTest() string {
	if x != nil {
		if x, ok := x.Payload.(*Data_RangeTest); ok {
			return x.RangeTest
		}
	}
	return ""
}

func (x *Data) GetZpsApp() []byte {
	if x != nil {
		if x, ok := x.Payload.(*Data_ZpsApp); ok {
			return x.ZpsApp
		}
	}
	return nil
}

func (x *Data) GetSimulator() []byte {
	if x != nil {
		if x, ok := x.Payload.(*Data_Simulator); ok {
			return x.Simulator
		}
	}
	return nil
}

func (x *Data) GetAtakPlugin() []byte {
	if x != nil {
		if x, ok := x.Payload.(*Data_AtakPlugin); ok {
			return x.AtakPlugin
		}
	}
	return nil
}

func (x *Data) GetPowerstress() []byte {
	if x != nil {
		if x, ok := x.Payload.(*Data_Powerstress); ok {
			return x.Powerstress
		}
	}
	return nil
}

func (x *Data) GetReticulumTunnel() []byte {
	if x != nil {
		if x, ok := x.Payload.(*Data_ReticulumTunnel); ok {
			return x.ReticulumTunnel
		}
	}
	return nil
}

func (x *Data) GetPrivateApp() []byte {
	if x != nil {
		if x, ok := x.Payload.(*Data_PrivateApp); ok {
			return x.PrivateApp
		}
	}
	return nil
}

func (x *Data) GetDetectionSensor() string {
	if x != nil {
		if x, ok := x.Payload.(*Data_DetectionSensor); ok {
			return x.DetectionSensor
		}
	}
	return ""
}

func (x *Data) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *Data) GetReplyId() uint32 {
	if x != nil {
		return x.ReplyId
	}
	return 0
}

func (x *Data) GetEmoji() uint32 {
	if x != nil {
		return x.Emoji
	}
	return 0
}

func (x *Data) GetDest() uint32 {
	if x != nil {
		return x.Dest
	}
	return 0
}

func (x *Data) GetSource() uint32 {
	if x != nil {
		return x.Source
	}
	return 0
}

func (x *Data) GetWantResponse() bool {
	if x != nil {
		return x.WantResponse
	}
	return false
}

func (x *Data) GetDecodeError() string {
	if x != nil {
		return x.DecodeError
	}
	return ""
}

func (x *Data) GetRxTime() uint64 {
	if x != nil {
		return x.RxTime
	}
	return 0
}

type isData_Payload interface {
	isData_Payload()
}

type Data_TextMessage struct {
	TextMessage string `protobuf:"bytes,14,opt,name=text_message,json=textMessage,proto3,oneof"` // TEXT_MESSAGE_APP
}

type Data_BinaryData struct {
	BinaryData []byte `protobuf:"bytes,15,opt,name=binary_data,json=binaryData,proto3,oneof"` // Generic binary data for other port types
}

type Data_Position struct {
	Position *meshtastic.Position `protobuf:"bytes,16,opt,name=position,proto3,oneof"` // POSITION_APP
}

type Data_NodeInfo struct {
	NodeInfo *meshtastic.User `protobuf:"bytes,17,opt,name=node_info,json=nodeInfo,proto3,oneof"` // NODEINFO_APP
}

type Data_Telemetry struct {
	Telemetry *meshtastic.Telemetry `protobuf:"bytes,18,opt,name=telemetry,proto3,oneof"` // TELEMETRY_APP
}

type Data_Waypoint struct {
	Waypoint *meshtastic.Waypoint `protobuf:"bytes,19,opt,name=waypoint,proto3,oneof"` // WAYPOINT_APP
}

type Data_RouteDiscovery struct {
	RouteDiscovery *meshtastic.RouteDiscovery `protobuf:"bytes,20,opt,name=route_discovery,json=routeDiscovery,proto3,oneof"` // TRACEROUTE_APP
}

type Data_NeighborInfo struct {
	NeighborInfo *meshtastic.NeighborInfo `protobuf:"bytes,21,opt,name=neighbor_info,json=neighborInfo,proto3,oneof"` // NEIGHBORINFO_APP
}

type Data_CompressedText struct {
	CompressedText []byte `protobuf:"bytes,22,opt,name=compressed_text,json=compressedText,proto3,oneof"` // TEXT_MESSAGE_COMPRESSED_APP
}

type Data_MapReport struct {
	MapReport *meshtastic.MapReport `protobuf:"bytes,23,opt,name=map_report,json=mapReport,proto3,oneof"` // MAP_REPORT_APP
}

type Data_RemoteHardware struct {
	RemoteHardware *meshtastic.HardwareMessage `protobuf:"bytes,24,opt,name=remote_hardware,json=remoteHardware,proto3,oneof"` // REMOTE_HARDWARE_APP
}

type Data_Routing struct {
	Routing *meshtastic.Routing `protobuf:"bytes,25,opt,name=routing,proto3,oneof"` // ROUTING_APP
}

type Data_Admin struct {
	Admin *meshtastic.AdminMessage `protobuf:"bytes,26,opt,name=admin,proto3,oneof"` // ADMIN_APP
}

type Data_AudioData struct {
	AudioData []byte `protobuf:"bytes,27,opt,name=audio_data,json=audioData,proto3,oneof"` // AUDIO_APP
}

type Data_Alert struct {
	Alert string `protobuf:"bytes,28,opt,name=alert,proto3,oneof"` // ALERT_APP
}

type Data_Reply struct {
	Reply string `protobuf:"bytes,29,opt,name=reply,proto3,oneof"` // REPLY_APP
}

type Data_IpTunnel struct {
	IpTunnel []byte `protobuf:"bytes,30,opt,name=ip_tunnel,json=ipTunnel,proto3,oneof"` // IP_TUNNEL_APP
}

type Data_Paxcounter struct {
	Paxcounter *meshtastic.Paxcount `protobuf:"bytes,31,opt,name=paxcounter,proto3,oneof"` // PAXCOUNTER_APP
}

type Data_SerialApp struct {
	SerialApp []byte `protobuf:"bytes,32,opt,name=serial_app,json=serialApp,proto3,oneof"` // SERIAL_APP
}

type Data_StoreForward struct {
	StoreForward []byte `protobuf:"bytes,33,opt,name=store_forward,json=storeForward,proto3,oneof"` // STORE_FORWARD_APP
}

type Data_RangeTest struct {
	RangeTest string `protobuf:"bytes,34,opt,name=range_test,json=rangeTest,proto3,oneof"` // RANGE_TEST_APP
}

type Data_ZpsApp struct {
	ZpsApp []byte `protobuf:"bytes,35,opt,name=zps_app,json=zpsApp,proto3,oneof"` // ZPS_APP
}

type Data_Simulator struct {
	Simulator []byte `protobuf:"bytes,36,opt,name=simulator,proto3,oneof"` // SIMULATOR_APP
}

type Data_AtakPlugin struct {
	AtakPlugin []byte `protobuf:"bytes,37,opt,name=atak_plugin,json=atakPlugin,proto3,oneof"` // ATAK_PLUGIN
}

type Data_Powerstress struct {
	Powerstress []byte `protobuf:"bytes,38,opt,name=powerstress,proto3,oneof"` // POWERSTRESS_APP
}

type Data_ReticulumTunnel struct {
	ReticulumTunnel []byte `protobuf:"bytes,39,opt,name=reticulum_tunnel,json=reticulumTunnel,proto3,oneof"` // RETICULUM_TUNNEL_APP
}

type Data_PrivateApp struct {
	PrivateApp []byte `protobuf:"bytes,40,opt,name=private_app,json=privateApp,proto3,oneof"` // PRIVATE_APP, ATAK_FORWARDER
}

type Data_DetectionSensor struct {
	DetectionSensor string `protobuf:"bytes,41,opt,name=detection_sensor,json=detectionSensor,proto3,oneof"` // DETECTION_SENSOR_APP
}

func (*Data_TextMessage) isData_Payload() {}

func (*Data_BinaryData) isData_Payload() {}

func (*Data_Position) isData_Payload() {}

func (*Data_NodeInfo) isData_Payload() {}

func (*Data_Telemetry) isData_Payload() {}

func (*Data_Waypoint) isData_Payload() {}

func (*Data_RouteDiscovery) isData_Payload() {}

func (*Data_NeighborInfo) isData_Payload() {}

func (*Data_CompressedText) isData_Payload() {}

func (*Data_MapReport) isData_Payload() {}

func (*Data_RemoteHardware) isData_Payload() {}

func (*Data_Routing) isData_Payload() {}

func (*Data_Admin) isData_Payload() {}

func (*Data_AudioData) isData_Payload() {}

func (*Data_Alert) isData_Payload() {}

func (*Data_Reply) isData_Payload() {}

func (*Data_IpTunnel) isData_Payload() {}

func (*Data_Paxcounter) isData_Payload() {}

func (*Data_SerialApp) isData_Payload() {}

func (*Data_StoreForward) isData_Payload() {}

func (*Data_RangeTest) isData_Payload() {}

func (*Data_ZpsApp) isData_Payload() {}

func (*Data_Simulator) isData_Payload() {}

func (*Data_AtakPlugin) isData_Payload() {}

func (*Data_Powerstress) isData_Payload() {}

func (*Data_ReticulumTunnel) isData_Payload() {}

func (*Data_PrivateApp) isData_Payload() {}

func (*Data_DetectionSensor) isData_Payload() {}

var File_meshstream_meshstream_proto protoreflect.FileDescriptor

const file_meshstream_meshstream_proto_rawDesc = "" +
	"\n" +
	"\x1bmeshstream/meshstream.proto\x12\n" +
	"meshstream\x1a\x15meshtastic/mesh.proto\x1a\x19meshtastic/portnums.proto\x1a\x1ameshtastic/telemetry.proto\x1a\x15meshtastic/mqtt.proto\x1a meshtastic/remote_hardware.proto\x1a\x16meshtastic/admin.proto\x1a\x19meshtastic/paxcount.proto\"Y\n" +
	"\x06Packet\x12)\n" +
	"\x04info\x18\x02 \x01(\v2\x15.meshstream.TopicInfoR\x04info\x12$\n" +
	"\x04data\x18\x01 \x01(\v2\x10.meshstream.DataR\x04data\"\xb0\x01\n" +
	"\tTopicInfo\x12\x1d\n" +
	"\n" +
	"full_topic\x18\x01 \x01(\tR\tfullTopic\x12\x1f\n" +
	"\vregion_path\x18\x02 \x01(\tR\n" +
	"regionPath\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x12\x16\n" +
	"\x06format\x18\x04 \x01(\tR\x06format\x12\x18\n" +
	"\achannel\x18\x05 \x01(\tR\achannel\x12\x17\n" +
	"\auser_id\x18\x06 \x01(\tR\x06userId\"\x94\x0e\n" +
	"\x04Data\x12\x1d\n" +
	"\n" +
	"channel_id\x18\x01 \x01(\tR\tchannelId\x12\x1d\n" +
	"\n" +
	"gateway_id\x18\x02 \x01(\tR\tgatewayId\x12\x0e\n" +
	"\x02id\x18\x03 \x01(\rR\x02id\x12\x12\n" +
	"\x04from\x18\x04 \x01(\rR\x04from\x12\x0e\n" +
	"\x02to\x18\x05 \x01(\rR\x02to\x12\x1b\n" +
	"\thop_limit\x18\x06 \x01(\rR\bhopLimit\x12\x1b\n" +
	"\thop_start\x18\a \x01(\rR\bhopStart\x12\x19\n" +
	"\bwant_ack\x18\b \x01(\bR\awantAck\x12\x1a\n" +
	"\bpriority\x18\t \x01(\tR\bpriority\x12\x19\n" +
	"\bvia_mqtt\x18\n" +
	" \x01(\bR\aviaMqtt\x12\x19\n" +
	"\bnext_hop\x18\v \x01(\rR\anextHop\x12\x1d\n" +
	"\n" +
	"relay_node\x18\f \x01(\rR\trelayNode\x12.\n" +
	"\bport_num\x18\r \x01(\x0e2\x13.meshtastic.PortNumR\aportNum\x12#\n" +
	"\ftext_message\x18\x0e \x01(\tH\x00R\vtextMessage\x12!\n" +
	"\vbinary_data\x18\x0f \x01(\fH\x00R\n" +
	"binaryData\x122\n" +
	"\bposition\x18\x10 \x01(\v2\x14.meshtastic.PositionH\x00R\bposition\x12/\n" +
	"\tnode_info\x18\x11 \x01(\v2\x10.meshtastic.UserH\x00R\bnodeInfo\x125\n" +
	"\ttelemetry\x18\x12 \x01(\v2\x15.meshtastic.TelemetryH\x00R\ttelemetry\x122\n" +
	"\bwaypoint\x18\x13 \x01(\v2\x14.meshtastic.WaypointH\x00R\bwaypoint\x12E\n" +
	"\x0froute_discovery\x18\x14 \x01(\v2\x1a.meshtastic.RouteDiscoveryH\x00R\x0erouteDiscovery\x12?\n" +
	"\rneighbor_info\x18\x15 \x01(\v2\x18.meshtastic.NeighborInfoH\x00R\fneighborInfo\x12)\n" +
	"\x0fcompressed_text\x18\x16 \x01(\fH\x00R\x0ecompressedText\x126\n" +
	"\n" +
	"map_report\x18\x17 \x01(\v2\x15.meshtastic.MapReportH\x00R\tmapReport\x12F\n" +
	"\x0fremote_hardware\x18\x18 \x01(\v2\x1b.meshtastic.HardwareMessageH\x00R\x0eremoteHardware\x12/\n" +
	"\arouting\x18\x19 \x01(\v2\x13.meshtastic.RoutingH\x00R\arouting\x120\n" +
	"\x05admin\x18\x1a \x01(\v2\x18.meshtastic.AdminMessageH\x00R\x05admin\x12\x1f\n" +
	"\n" +
	"audio_data\x18\x1b \x01(\fH\x00R\taudioData\x12\x16\n" +
	"\x05alert\x18\x1c \x01(\tH\x00R\x05alert\x12\x16\n" +
	"\x05reply\x18\x1d \x01(\tH\x00R\x05reply\x12\x1d\n" +
	"\tip_tunnel\x18\x1e \x01(\fH\x00R\bipTunnel\x126\n" +
	"\n" +
	"paxcounter\x18\x1f \x01(\v2\x14.meshtastic.PaxcountH\x00R\n" +
	"paxcounter\x12\x1f\n" +
	"\n" +
	"serial_app\x18  \x01(\fH\x00R\tserialApp\x12%\n" +
	"\rstore_forward\x18! \x01(\fH\x00R\fstoreForward\x12\x1f\n" +
	"\n" +
	"range_test\x18\" \x01(\tH\x00R\trangeTest\x12\x19\n" +
	"\azps_app\x18# \x01(\fH\x00R\x06zpsApp\x12\x1e\n" +
	"\tsimulator\x18$ \x01(\fH\x00R\tsimulator\x12!\n" +
	"\vatak_plugin\x18% \x01(\fH\x00R\n" +
	"atakPlugin\x12\"\n" +
	"\vpowerstress\x18& \x01(\fH\x00R\vpowerstress\x12+\n" +
	"\x10reticulum_tunnel\x18' \x01(\fH\x00R\x0freticulumTunnel\x12!\n" +
	"\vprivate_app\x18( \x01(\fH\x00R\n" +
	"privateApp\x12+\n" +
	"\x10detection_sensor\x18) \x01(\tH\x00R\x0fdetectionSensor\x12\x1d\n" +
	"\n" +
	"request_id\x182 \x01(\rR\trequestId\x12\x19\n" +
	"\breply_id\x183 \x01(\rR\areplyId\x12\x14\n" +
	"\x05emoji\x184 \x01(\rR\x05emoji\x12\x12\n" +
	"\x04dest\x185 \x01(\rR\x04dest\x12\x16\n" +
	"\x06source\x186 \x01(\rR\x06source\x12#\n" +
	"\rwant_response\x187 \x01(\bR\fwantResponse\x12!\n" +
	"\fdecode_error\x18< \x01(\tR\vdecodeError\x12\x17\n" +
	"\arx_time\x18= \x01(\x04R\x06rxTimeB\t\n" +
	"\apayloadB(Z&proto/generated/meshstream;meshtreampbb\x06proto3"

var (
	file_meshstream_meshstream_proto_rawDescOnce sync.Once
	file_meshstream_meshstream_proto_rawDescData []byte
)

func file_meshstream_meshstream_proto_rawDescGZIP() []byte {
	file_meshstream_meshstream_proto_rawDescOnce.Do(func() {
		file_meshstream_meshstream_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_meshstream_meshstream_proto_rawDesc), len(file_meshstream_meshstream_proto_rawDesc)))
	})
	return file_meshstream_meshstream_proto_rawDescData
}

var file_meshstream_meshstream_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_meshstream_meshstream_proto_goTypes = []any{
	(*Packet)(nil),                     // 0: meshstream.Packet
	(*TopicInfo)(nil),                  // 1: meshstream.TopicInfo
	(*Data)(nil),                       // 2: meshstream.Data
	(meshtastic.PortNum)(0),            // 3: meshtastic.PortNum
	(*meshtastic.Position)(nil),        // 4: meshtastic.Position
	(*meshtastic.User)(nil),            // 5: meshtastic.User
	(*meshtastic.Telemetry)(nil),       // 6: meshtastic.Telemetry
	(*meshtastic.Waypoint)(nil),        // 7: meshtastic.Waypoint
	(*meshtastic.RouteDiscovery)(nil),  // 8: meshtastic.RouteDiscovery
	(*meshtastic.NeighborInfo)(nil),    // 9: meshtastic.NeighborInfo
	(*meshtastic.MapReport)(nil),       // 10: meshtastic.MapReport
	(*meshtastic.HardwareMessage)(nil), // 11: meshtastic.HardwareMessage
	(*meshtastic.Routing)(nil),         // 12: meshtastic.Routing
	(*meshtastic.AdminMessage)(nil),    // 13: meshtastic.AdminMessage
	(*meshtastic.Paxcount)(nil),        // 14: meshtastic.Paxcount
}
var file_meshstream_meshstream_proto_depIdxs = []int32{
	1,  // 0: meshstream.Packet.info:type_name -> meshstream.TopicInfo
	2,  // 1: meshstream.Packet.data:type_name -> meshstream.Data
	3,  // 2: meshstream.Data.port_num:type_name -> meshtastic.PortNum
	4,  // 3: meshstream.Data.position:type_name -> meshtastic.Position
	5,  // 4: meshstream.Data.node_info:type_name -> meshtastic.User
	6,  // 5: meshstream.Data.telemetry:type_name -> meshtastic.Telemetry
	7,  // 6: meshstream.Data.waypoint:type_name -> meshtastic.Waypoint
	8,  // 7: meshstream.Data.route_discovery:type_name -> meshtastic.RouteDiscovery
	9,  // 8: meshstream.Data.neighbor_info:type_name -> meshtastic.NeighborInfo
	10, // 9: meshstream.Data.map_report:type_name -> meshtastic.MapReport
	11, // 10: meshstream.Data.remote_hardware:type_name -> meshtastic.HardwareMessage
	12, // 11: meshstream.Data.routing:type_name -> meshtastic.Routing
	13, // 12: meshstream.Data.admin:type_name -> meshtastic.AdminMessage
	14, // 13: meshstream.Data.paxcounter:type_name -> meshtastic.Paxcount
	14, // [14:14] is the sub-list for method output_type
	14, // [14:14] is the sub-list for method input_type
	14, // [14:14] is the sub-list for extension type_name
	14, // [14:14] is the sub-list for extension extendee
	0,  // [0:14] is the sub-list for field type_name
}

func init() { file_meshstream_meshstream_proto_init() }
func file_meshstream_meshstream_proto_init() {
	if File_meshstream_meshstream_proto != nil {
		return
	}
	file_meshstream_meshstream_proto_msgTypes[2].OneofWrappers = []any{
		(*Data_TextMessage)(nil),
		(*Data_BinaryData)(nil),
		(*Data_Position)(nil),
		(*Data_NodeInfo)(nil),
		(*Data_Telemetry)(nil),
		(*Data_Waypoint)(nil),
		(*Data_RouteDiscovery)(nil),
		(*Data_NeighborInfo)(nil),
		(*Data_CompressedText)(nil),
		(*Data_MapReport)(nil),
		(*Data_RemoteHardware)(nil),
		(*Data_Routing)(nil),
		(*Data_Admin)(nil),
		(*Data_AudioData)(nil),
		(*Data_Alert)(nil),
		(*Data_Reply)(nil),
		(*Data_IpTunnel)(nil),
		(*Data_Paxcounter)(nil),
		(*Data_SerialApp)(nil),
		(*Data_StoreForward)(nil),
		(*Data_RangeTest)(nil),
		(*Data_ZpsApp)(nil),
		(*Data_Simulator)(nil),
		(*Data_AtakPlugin)(nil),
		(*Data_Powerstress)(nil),
		(*Data_ReticulumTunnel)(nil),
		(*Data_PrivateApp)(nil),
		(*Data_DetectionSensor)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_meshstream_meshstream_proto_rawDesc), len(file_meshstream_meshstream_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_meshstream_meshstream_proto_goTypes,
		DependencyIndexes: file_meshstream_meshstream_proto_depIdxs,
		MessageInfos:      file_meshstream_meshstream_proto_msgTypes,
	}.Build()
	File_meshstream_meshstream_proto = out.File
	file_meshstream_meshstream_proto_goTypes = nil
	file_meshstream_meshstream_proto_depIdxs = nil
}
